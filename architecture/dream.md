# micro-services code generator

- Objectives
    - Generate backend and frontend services from a meta-model
    - Main goal: enable easy custom code “on top of generated code”
    - Micro-backend / micro-frontend pattern
    - V1: TypeScript, future versions: .NET, Java
    - Deployment targets: VM, Docker, K8s
    - GitOps as the source of truth
- Meta-model
    - YAML format (Git-friendly, editable manually and via UI)
    - Definition of entities and relationships
    - API configuration (REST OpenAPI + gRPC)
    - CRUD configuration per entity
    - Validation via JSON Schema (to be confirmed)
- Backend
    - Language: TypeScript (V1), .NET and Java (future versions)
    - APIs: REST (OpenAPI) + gRPC
    - Inter-service communication: gRPC + message broker
    - Communication to frontend: REST only
    - CRUD automatically generated but custom-code-first oriented
    - Deployment: K8s (V1), Docker
    - Deployment DevOps also part of generated deliverable
        - Must be deployable by instantiation (configurable)
- Frontend
    - Architecture: Web Components
    - Pattern: one backend service = one or more web components
    - Communication: REST to backends
    - Inter-component communication: Custom Events / shared state / comp-to-comp
    - Bundling and distribution: to be defined
- Portal
    - Shell application to assemble web components
    - Orchestration and routing
    - Dynamic component loading
- Security
    - Centralized SSO
    - Shared token among web components (no re-authentication)
    - Backend-to-backend propagation (mechanism to be defined)
    - Private npm package for shared auth logic and others
    - External SSO provider (to define: Keycloak, Auth0, etc.)
- Generator
    - (V1) CLI tool in TypeScript (to be confirmed)
    - Templating: LIT (V1), Angular, React
    - Distribution: npm package
    - Input: YAML files
    - Output: backend code, frontend code, deployment configs, API specs
- DevOps
    - GitOps: Git as the source of truth
    - Mono-repo per service (frontend + backend together)
    - Shared packages: private npm (auth, logging, etc.)
    - CI/CD: YAML change detection → generation → deployment (to confirm)
    - Private npm registry (to define)
    - Strict semantic versioning
- Pending points
    - Backend framework V1: NestJS
    - ORM: TypeORM
    - Message broker: RabbitMQ (V1), Kafka, Redis Streams
    - Web components library: Lit, Stencil, vanilla
    - Frontend state management
    - SSO provider
    - CI/CD tooling
    - Number of environments
- DevOps and Infrastructure Section
    - Infrastructure stack must use open-source products and be part of CNCF
    - Discovery and Communication
        - Dapr (sidecar pattern) for multi-language orchestration
        - Service invocation via Dapr: HTTP/gRPC abstraction
        - Native discovery: resolution by Dapr App-ID
        - Inter-service communication: automatic mTLS via Dapr
        - No discovery/retry logic in application code
        - Portability ensured across TypeScript, .NET, Java
    - Authentication and Security
        - Ingress Gateway (Traefik or Nginx): JWT SSO validation at entry
        - Dapr sidecar: automatic inter-service mTLS
        - Dapr Secrets API: secure access to tokens/credentials
        - Application services: no auth code, pure business logic
        - Token propagation via Dapr headers
        - Shared package: extract claims only when needed
    - Message Broker
        - Dapr Pub/Sub building block: broker abstraction
        - Switch provider without code changes (Redis, Kafka, RabbitMQ)
        - Configuration via Dapr components
        - Native multi-language support
    - State and Configuration
        - Dapr State Management: distributed cache if needed
        - Dapr Configuration API: externalized configs
        - Interchangeable providers (Redis, Cosmos, etc.)
    - Observability
        - Distributed tracing via Dapr (Zipkin, Jaeger)
        - Automatic Prometheus metrics
        - Centralized logs (to define: ELK, Loki)
        - No code instrumentation required
    - Deployment
        - Local: Dapr self-hosted mode (development)
        - K8s: automatic sidecar injection via annotations
        - Docker: dapr run with docker-compose
        - VM: Dapr runtime installed, services registered
        - Dapr manifests and configs generated by CLI
    - API Gateway and Documentation (Kong)
        - Role
            - Single entry point for all APIs
            - Centralized JWT validation (services don’t handle auth)
            - Routing to backend services via Dapr
        - Documentation
            - OpenAPI specs generated by CLI
            - Automatically published to Kong via Admin API
            - Backend services do not expose Swagger UI
            - Kong Dev Portal to explore and test APIs
        - Features
            - Centralized rate limiting and CORS
            - Request validation according to OpenAPI specs
            - JWT claims extraction and propagation via headers
            - Observability (logs, call metrics)
        - Workflow
            - Generation produces code + openapi.yaml + Kong config
            - CI/CD publishes specs and config to Kong
            - Dev Portal reflects changes immediately
            - API testing via Kong interface
